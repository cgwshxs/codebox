#include<iostream>
#include<stdio.h>
#include<math.h>
#include<limits.h>
#include<queue>
using namespace std;
int const maxn=10000000;
int const maxm=20000000;
struct node{
  int t,w;
  node *next;
}edge[maxm],*adj[maxn],*nadj[maxn];//edge保存边的数组 adj保存顺的边,nadj保存逆的边
int len=0;
void init(int n){
  for(int i=0;i<n;i++){
    adj[i]=NULL;nadj[i]=NULL;
  }
  len=0;
}
void addedge(node *adj[],int u,int v,int w){
  edge[len].t=v;
  edge[len].w=w;
  edge[len].next=adj[u];
  adj[u]=&edge[len++];//u->v
}
void insert(int u,int v,int w)
{
  addedge(adj,u,v,w);
  addedge(adj,v,u,w);
}
int use[maxn];
long long dis[maxn];
queue<int>Q;
void SPFA(node *adj[],int n,int s,int t)
{
  while(!Q.empty())
    Q.pop();
  fill(use,use+n,0);
  fill(dis,dis+n,INT_MAX);
  Q.push(s);
  use[s]=1;//起点被使用
  dis[s]=0;
  while(!Q.empty())
    {
      int t=Q.front();
      Q.pop();
      use[t]=0;
      for(node *p=adj[t];p;p=p->next){
	if(dis[t]+p->w<dis[p->t]){
	  dis[p->t]=dis[t]+p->w;
	  if(!use[p->t]){
	    use[p->t]=1;
	    Q.push(p->t);
	  }
	}
      }
    }
  if(dis[t]==INT_MAX)
    return -1;
  else
    return dis[t];
}

int main(){
  int T;
  can>>T;
  while(T--)
    {
      int n,m;
      scanf("%d%d",&n,&m);
      init(n);
      for(int i=0;i<m;i++)
	{
	  int a,b,c;
	  scanf("%d%d%d",&a,&b,&c);
	  insert(a-1,b-1,c);
	}
      SPFA(adj,n,0,n-1);
      for(int i=0;i<n;i++)
	sum+=dis[i];
      printf("%lld\n",sum);
    }
  return 0;
}
